<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>CAP-402 SDK Reference</title>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
  <script src="https://unpkg.com/lucide@latest"></script>
  <style>
    :root {
      --arcium-purple: #6C44FC;
      --bg-dark: #0a0a0c;
      --bg-card: rgba(255,255,255,0.03);
      --border-subtle: rgba(255,255,255,0.08);
      --text-primary: #fafafa;
      --text-secondary: #888;
      --green: #22c55e;
    }
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { font-family: 'Inter', sans-serif; background: var(--bg-dark); color: var(--text-primary); min-height: 100vh; line-height: 1.6; }
    .topbar { background: linear-gradient(135deg, var(--bg-dark) 0%, #1a1a2e 100%); padding: 1rem 2rem; border-bottom: 1px solid var(--border-subtle); display: flex; justify-content: space-between; align-items: center; position: sticky; top: 0; z-index: 100; }
    .topbar-left { display: flex; align-items: center; gap: 0.75rem; }
    .topbar-left img { height: 28px; }
    .topbar-left h1 { font-size: 1rem; color: var(--text-primary); }
    .nav-links { display: flex; gap: 0.5rem; }
    .nav-links a { padding: 0.4rem 0.8rem; background: var(--bg-card); border: 1px solid var(--border-subtle); border-radius: 6px; font-size: 0.8rem; color: var(--text-secondary); text-decoration: none; transition: all 0.2s; }
    .nav-links a:hover { background: rgba(108, 68, 252, 0.15); border-color: var(--arcium-purple); color: var(--text-primary); }
    .container { max-width: 900px; margin: 0 auto; padding: 2rem; }
    h1 { font-size: 2rem; margin-bottom: 0.5rem; }
    h2 { font-size: 1.25rem; margin-top: 2rem; padding-top: 1rem; border-top: 1px solid var(--border-subtle); color: var(--text-primary); }
    h3 { font-size: 1rem; margin: 1.5rem 0 0.75rem; color: var(--arcium-purple); }
    p { color: var(--text-secondary); margin-bottom: 1rem; }
    .code-block { background: #111; border: 1px solid var(--border-subtle); border-radius: 6px; padding: 1rem; font-family: 'JetBrains Mono', monospace; font-size: 0.8rem; color: var(--green); overflow-x: auto; margin: 1rem 0; white-space: pre; }
    table { width: 100%; border-collapse: collapse; margin: 1rem 0; }
    th, td { border: 1px solid var(--border-subtle); padding: 0.5rem 1rem; text-align: left; }
    th { background: var(--bg-card); color: var(--text-primary); }
    td { color: var(--text-secondary); }
    ul { margin: 1rem 0; padding-left: 1.5rem; color: var(--text-secondary); }
    li { margin-bottom: 0.5rem; }
    strong { color: var(--text-primary); }

    /* CAP-402 Brand Icons - Lucide */
    .cap-icon {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 28px;
      height: 28px;
      border-radius: 6px;
      background: linear-gradient(135deg, rgba(108,68,252,0.12) 0%, rgba(108,68,252,0.04) 100%);
      border: 1px solid rgba(108,68,252,0.25);
      flex-shrink: 0;
      vertical-align: middle;
      margin-right: 0.5rem;
      transition: all 0.2s ease;
    }
    .cap-icon svg {
      width: 14px;
      height: 14px;
      stroke: var(--arcium-purple);
      stroke-width: 2;
    }
    .cap-icon:hover {
      background: linear-gradient(135deg, rgba(108,68,252,0.2) 0%, rgba(108,68,252,0.08) 100%);
      border-color: rgba(108,68,252,0.4);
    }
    .cap-icon.icon-green {
      background: linear-gradient(135deg, rgba(34,197,94,0.12) 0%, rgba(34,197,94,0.04) 100%);
      border-color: rgba(34,197,94,0.25);
    }
    .cap-icon.icon-green svg {
      stroke: #22c55e;
    }
  </style>
</head>
<body>
  <div class="topbar">
    <div class="topbar-left">
      <a href="/"><img src="/public/logo2.png" alt="CAP-402"></a>
      <h1>SDK Reference</h1>
    </div>
    <div class="nav-links">
      <a href="/docs">Docs</a>
      <a href="/docs/api-docs.html">API</a>
      <a href="/docs/whitepaper.html">Whitepaper</a>
      <a href="/">Home</a>
      <a href="https://github.com/TheQuantumChronicle/CAP402" target="_blank">GitHub</a>
    </div>
  </div>
  
  <div class="container">
    <h1>Agent SDK Reference</h1>
    <p>Build autonomous agents that monitor markets, analyze risk, and prepare ready-to-sign transactions. You sign‚Äîagents do the rest.</p>

    <h2>Why Use Agents?</h2>
    <table>
      <tr><th>Use Case</th><th>Without Agent</th><th>With Agent</th></tr>
      <tr><td>Price Alerts</td><td>Manually check prices</td><td>Agent monitors 24/7, alerts you</td></tr>
      <tr><td>Trading</td><td>Research ‚Üí Calculate ‚Üí Execute</td><td>One line: <code>trader.smartSwap('SOL', 'USDC', 100)</code></td></tr>
      <tr><td>MEV Protection</td><td>Hope you don't get front-run</td><td>Built-in risk analysis + protection</td></tr>
      <tr><td>Best Execution</td><td>Compare DEXs manually</td><td>Agent finds best route (DEX or A2A)</td></tr>
      <tr><td>Portfolio</td><td>Spreadsheets</td><td>Real-time tracking + P&L</td></tr>
    </table>

    <h2>When to Use What</h2>
    <pre class="code-block">// QUICK OPERATIONS - No setup needed
import { cap402, prepareSwap, findAlpha } from '@cap402/sdk';

await cap402.price('SOL');              // Get price
await prepareSwap('SOL', 'USDC', 10);   // Prepare swap tx
await findAlpha(['SOL', 'ETH']);        // Detect signals

// TRADING AGENT - Continuous monitoring + trading
import { createTradingAgent } from '@cap402/sdk';
const trader = createTradingAgent({ ... });
trader.on('signal', ...);  // React to signals
await trader.start();      // Runs 24/7

// MONITORING AGENT - Watch wallets/protocols
import { createMonitoringAgent } from '@cap402/sdk';
const monitor = createMonitoringAgent({ ... });
monitor.on('alert', ...);  // Get notified

// ANALYTICS AGENT - Collect data + generate reports
import { createAnalyticsAgent } from '@cap402/sdk';
const analytics = createAnalyticsAgent({ ... });
analytics.on('report_generated', ...);</pre>

    <h2>Quick Start</h2>
    <pre class="code-block">import { cap402 } from '@cap402/sdk';

// One-liner operations
const price = await cap402.price('SOL');           // $143.34
const wallet = await cap402.wallet('address...');
const swap = await cap402.swap('SOL', 'USDC', 10); // dry_run by default</pre>
    
    <h2>New Capabilities (Jan 2026)</h2>
    
    <h3>Private AI Inference</h3>
    <p>Run AI models with encrypted inputs - your data never exposed.</p>
    <pre class="code-block">import { createClient } from '@cap402/sdk';

const client = createClient('https://api.cap402.com');

// Private sentiment analysis
const result = await client.invokeCapability('cap.ai.inference.v1', {
  model: 'sentiment-analysis',
  input: 'This product is amazing!',
  privacy_level: 2 // Confidential (Arcium MPC)
});
// { result: { sentiment: 'positive', confidence: 0.92 }, proof: '...' }

// Private embeddings for RAG
const embeddings = await client.invokeCapability('cap.ai.embedding.v1', {
  texts: ['Hello world', 'Goodbye world'],
  privacy_level: 2
});
// { embeddings: [[...], [...]], dimensions: 1536 }</pre>

    <h3>Private KYC Verification</h3>
    <p>Prove compliance without revealing personal data using zero-knowledge proofs.</p>
    <pre class="code-block">// Prove you're 18+ without revealing birthdate
const result = await client.invokeCapability('cap.zk.kyc.v1', {
  verification_type: 'age',
  private_inputs: {
    date_of_birth: '1990-05-15' // NEVER revealed
  },
  public_inputs: {
    min_age: 18
  }
});
// { compliant: true, proof: '0x...', verification_id: 'kyc_abc123' }
// Verifier learns ONLY: "User is 18+" - nothing else</pre>

    <h3>Agent Framework Integrations</h3>
    <p>Ready-to-use integrations for popular AI agent frameworks.</p>
    <pre class="code-block">// LangChain
import { CAP402Toolkit } from '@cap402/sdk/integrations/langchain';
const toolkit = new CAP402Toolkit({ routerUrl: 'https://api.cap402.com' });
const tools = await toolkit.getTools();

// AutoGPT
import { CAP402AutoGPTPlugin } from '@cap402/sdk/integrations/autogpt';
const plugin = new CAP402AutoGPTPlugin();
const commands = plugin.getCommands();

// CrewAI
import { CAP402CrewAgent } from '@cap402/sdk/integrations/crewai';
const agent = new CAP402CrewAgent({
  role: 'Market Analyst',
  capabilities: ['cap.price.lookup.v1', 'cap.ai.inference.v1']
});</pre>
    
    <h2>Agent Templates</h2>
    <h3>Trading Agent</h3>
    <p>Monitors prices, generates signals, and prepares ready-to-sign swap transactions.</p>
    <pre class="code-block">import { createTradingAgent } from '@cap402/sdk';

const trader = createTradingAgent({
  agent_id: 'sol-trader',
  watched_tokens: ['SOL', 'ETH', 'BTC'],
  mev_protection: true
});

// Agent prepares transactions autonomously
trader.on('signal', async (signal) => {
  const tx = await trader.actOnSignal(signal, 10);
  // tx is ready for your wallet to sign
});

await trader.start();</pre>
    
    <h3>Prepared Transactions</h3>
    <p>Agents return ready-to-sign transactions with all details calculated:</p>
    <pre class="code-block">const prepared = await trader.prepareSwap('SOL', 'USDC', 10);

// Returns:
{
  instruction_id: 'prep_1705412400_abc123',
  type: 'swap',
  status: 'ready',
  expires_at: 1705412460000,
  
  token_in: 'SOL',
  token_out: 'USDC',
  amount_in: 10,
  expected_out: 1433.40,
  min_out: 1426.23,
  slippage_bps: 50,
  
  dex: 'jupiter',
  mev_risk: 'LOW',
  
  user_action_required: 'sign_and_submit',
  instructions_for_user: 'Swap 10 SOL for ~1433.40 USDC. Sign in wallet.'
}</pre>
    
    <h3>Monitoring Agent</h3>
    <p>Tracks wallet balances and protocol health, triggers alerts.</p>
    <pre class="code-block">import { createMonitoringAgent } from '@cap402/sdk';

const monitor = createMonitoringAgent({
  agent_id: 'wallet-monitor',
  watched_wallets: ['YOUR_WALLET_ADDRESS'],
  check_interval_ms: 60000,
  alert_channels: [{ type: 'console', enabled: true }]
});

monitor.on('alert', (alert) => {
  console.log(\`\${alert.severity}: \${alert.title}\`);
});

await monitor.start();</pre>
    
    <h3>Analytics Agent</h3>
    <p>Collects time-series data, generates reports and insights.</p>
    <pre class="code-block">import { createAnalyticsAgent } from '@cap402/sdk';

const analytics = createAnalyticsAgent({
  agent_id: 'market-analytics',
  data_sources: [{
    id: 'sol-price',
    type: 'price',
    capability_id: 'cap.price.lookup.v1',
    inputs: { base_token: 'SOL' },
    interval_ms: 60000,
    enabled: true
  }]
});

analytics.on('report_generated', (report) => {
  console.log('Insights:', report.insights);
});

await analytics.start();</pre>
    
    <h2>Safety Guardrails</h2>
    <p>Built-in protection with sensible defaults:</p>
    <table>
      <tr><th>Limit</th><th>Default</th><th>Description</th></tr>
      <tr><td>Per Transaction</td><td>$100</td><td>Maximum USD per single transaction</td></tr>
      <tr><td>Per Hour</td><td>$500</td><td>Maximum USD spending per hour</td></tr>
      <tr><td>Per Day</td><td>$2,000</td><td>Maximum USD spending per day</td></tr>
      <tr><td>Trades/Hour</td><td>20</td><td>Maximum trades per hour</td></tr>
      <tr><td>Invocations/Min</td><td>60</td><td>Rate limit per minute</td></tr>
    </table>
    <pre class="code-block">import { createSafetyGuardrails, SAFETY_PRESETS } from '@cap402/sdk';

// Use presets: conservative, standard, aggressive
const safety = createSafetyGuardrails(SAFETY_PRESETS.conservative);

// Or customize
const custom = createSafetyGuardrails({
  spending_limits: {
    max_per_transaction: 50,
    max_per_hour: 200
  },
  blocked_tokens: ['SCAM_TOKEN']
});</pre>
    
    <h2>One-Liner Convenience Methods</h2>
    <p>Simple methods for common operations:</p>
    <pre class="code-block">// Buy token (prepares transaction for signing)
const buyTx = await trader.buy('SOL', 100); // Buy $100 worth of SOL

// Sell token
const sellTx = await trader.sell('SOL', 10); // Sell 10 SOL

// Smart swap - auto-selects best route (DEX vs A2A)
const result = await trader.smartSwap('SOL', 'USDC', 100);
console.log(result.execution_summary);
// "A2A trade via agent-xyz: 100 SOL ‚Üí 14,334 USDC (0.5% better than DEX)"

// Check if trade is profitable
const check = await trader.isProfitable('SOL', 'USDC', 1000);
console.log(check.recommendation);

// Get portfolio value
const portfolio = await trader.getPortfolioValue();
console.log(\`Total: $\${portfolio.total_usd}\`);</pre>

    <h2>Agent-to-Agent (A2A) Trading</h2>
    <p>Trade directly with other agents for better prices and liquidity:</p>
    <pre class="code-block">// Find trading partners with quotes
const partners = await trader.findTradingPartners('SOL', 'USDC', 100);
console.log(\`Found \${partners.length} partners\`);
console.log(\`Best offer: \${partners[0].quote.amount_out} USDC\`);

// Execute A2A trade
const result = await trader.executeA2ATrade(partners[0].quote);
if (result.status === 'executed') {
  console.log(\`Received: \${result.amount_received} USDC\`);
}

// Auction - agents compete for best price
const auction = await trader.auctionTrade('SOL', 'USDC', 1000);
console.log(\`Winner: \${auction.winner?.agent_id} at \${auction.best_price}\`);

// Swarm trade - split large orders across agents
const swarm = await trader.swarmTrade('SOL', 'USDC', 10000, { minAgents: 3 });
console.log(\`Executed via \${swarm.participants.length} agents\`);
console.log(\`Total received: \${swarm.total_amount_out} USDC\`);</pre>

    <h3>Signal Sharing</h3>
    <pre class="code-block">// Broadcast signals to other agents
await trader.broadcastSignal(alphaSignal);

// Receive signals from other agents
trader.on('a2a_signal', ({ from, signal }) => {
  console.log(\`Signal from \${from}: \${signal.type} \${signal.token}\`);
});

// Poll for signals
const signals = await trader.pollA2ASignals();</pre>

    <h2>ü•∑ Stealth Trading Mode</h2>
    <p>Privacy-first trading with automatic privacy escalation for large trades:</p>
    <pre class="code-block">import { createTradingAgent } from '@cap402/sdk';

// Enable stealth mode
const trader = createTradingAgent({
  agent_id: 'stealth-bot',
  watched_tokens: ['SOL', 'ETH'],
  stealth_mode: {
    enabled: true,
    auto_privacy_threshold_usd: 10000,  // Auto-escalate > $10K
    auto_split_threshold_usd: 50000,    // Split orders > $50K
    randomize_timing: true,              // Random delays
    decoy_transactions: false            // Optional decoys
  }
});

// Analyze stealth options before trading
const analysis = await trader.analyzeStealthOptions('SOL', 'USDC', 1000);
console.log(analysis.recommendation);        // 'maximum'
console.log(analysis.mev_risk.level);        // 'HIGH'
console.log(analysis.stealth_options);       // Privacy/cost tradeoffs

// Execute stealth trade
const result = await trader.stealthTrade('SOL', 'USDC', 1000, {
  privacy_level: 'maximum',  // 'standard' | 'enhanced' | 'maximum'
  split_order: true,         // Split into chunks
  max_chunks: 5,             // Number of chunks
  use_decoys: false          // Decoy transactions
});

console.log(result.stealth_features_used);
// ['order_splitting', 'randomized_timing', 'arcium_mpc', 'encrypted_amounts']
console.log(\`MEV Savings: $\${result.mev_savings_usd}\`);
console.log(\`Privacy Cost: $\${result.privacy_cost_usd}\`);</pre>

    <h3>Privacy Levels</h3>
    <table>
      <tr><th>Level</th><th>Method</th><th>Protection</th><th>Features</th></tr>
      <tr><td>standard</td><td>Private RPC</td><td>40%</td><td>Hidden from public mempool</td></tr>
      <tr><td>enhanced</td><td>Jito Bundle</td><td>70%</td><td>Tip protection, atomic execution</td></tr>
      <tr><td>maximum</td><td>Arcium MPC</td><td>95%</td><td>Encrypted amounts, hidden route, ZK proof</td></tr>
    </table>

    <h3>Stealth Features</h3>
    <ul>
      <li><strong>Order Splitting</strong> ‚Äî Large orders split into chunks to avoid detection</li>
      <li><strong>Randomized Timing</strong> ‚Äî Random delays between chunks prevent pattern analysis</li>
      <li><strong>Decoy Transactions</strong> ‚Äî Optional fake trades to confuse observers</li>
      <li><strong>Encrypted Amounts</strong> ‚Äî Trade size hidden from all observers</li>
      <li><strong>Hidden Route</strong> ‚Äî Swap path through DEXs concealed</li>
      <li><strong>Auto-Escalation</strong> ‚Äî Privacy level automatically increases for large trades</li>
    </ul>

    <h2>‚ö° Instant Execution</h2>
    <p>Sub-second trade execution with caching, parallel requests, and smart routing:</p>
    <pre class="code-block">// Instant swap - fastest execution
const result = await trader.instantSwap('SOL', 'USDC', 10);
console.log(\`Executed in \${result.latency_ms}ms\`);

// Smart trade - auto-selects best method based on size
// < $100: instant (skip MEV)
// $100-$10K: protected (standard MEV)
// > $10K: stealth (split + max privacy)
const smart = await trader.smartTrade('SOL', 'USDC', 100);
console.log(\`Method: \${smart.method}\`); // 'instant' | 'protected' | 'stealth'

// Race swap - races multiple execution paths
const race = await trader.raceSwap('SOL', 'USDC', 10);
console.log(\`Winner: \${race.winning_method}\`);

// Warm up caches for fastest execution
await trader.warmUp([
  { tokenIn: 'SOL', tokenOut: 'USDC' },
  { tokenIn: 'ETH', tokenOut: 'USDC' }
]);</pre>

    <h2>üìä Risk Management</h2>
    <p>Automated stop-loss, take-profit, and trailing stops:</p>
    <pre class="code-block">// Stop-loss - sell when price drops below trigger
trader.setStopLoss('SOL', 140, 10, 'USDC');
// Sells 10 SOL if price drops below $140

// Take-profit - sell when price rises above trigger
trader.setTakeProfit('SOL', 200, 10, 'USDC');
// Sells 10 SOL if price rises above $200

// Trailing stop - follows price up, triggers on % drop
trader.setTrailingStop('SOL', 5, 10, 'USDC');
// Sells 10 SOL if price drops 5% from its high

// Cancel orders
trader.cancelOrder(order.order_id);

// Get active orders
const orders = trader.getActiveOrders();</pre>

    <h2>üìÖ DCA (Dollar Cost Averaging)</h2>
    <p>Automated recurring buys at regular intervals:</p>
    <pre class="code-block">// Start DCA - buy $50 of SOL every hour for 24 hours
const dca = trader.startDCA('SOL', 'USDC', 50, 'hourly', 24);

// Intervals: 'hourly' | 'daily' | 'weekly' | custom ms
trader.startDCA('ETH', 'USDC', 100, 'daily');      // Daily
trader.startDCA('BTC', 'USDC', 500, 'weekly');     // Weekly
trader.startDCA('SOL', 'USDC', 25, 60000);         // Every minute

// Control DCA
trader.pauseDCA(dca.schedule_id);
trader.resumeDCA(dca.schedule_id);
trader.stopDCA(dca.schedule_id);

// Track progress
const schedule = trader.getDCASchedule(dca.schedule_id);
console.log(\`Bought: \${schedule.total_acquired} SOL\`);
console.log(\`Avg price: $\${schedule.avg_price}\`);</pre>

    <h2>üìã Limit Orders</h2>
    <p>Buy or sell at specific prices:</p>
    <pre class="code-block">// Limit buy - buy when price drops to limit
trader.limitBuy('SOL', 'USDC', 10, 140);
// Buys 10 SOL when price drops to $140

// Limit sell - sell when price rises to limit
trader.limitSell('SOL', 'USDC', 10, 200);
// Sells 10 SOL when price rises to $200

// Cancel limit orders
trader.cancelLimitOrder(order.order_id);

// Get open limit orders
const limitOrders = trader.getOpenLimitOrders();</pre>

    <h2>‚öñÔ∏è Portfolio Rebalancing</h2>
    <p>Automatically rebalance to target allocations:</p>
    <pre class="code-block">// Rebalance to 60% SOL, 30% ETH, 10% USDC
const result = await trader.rebalance({
  SOL: 60,
  ETH: 30,
  USDC: 10
});

console.log(\`Trades executed: \${result.trades_executed}\`);
console.log('Before:', result.before);
console.log('After:', result.after);

// Dry run - preview without executing
const preview = await trader.rebalance(
  { SOL: 60, ETH: 30, USDC: 10 },
  { dry_run: true, tolerance_percent: 2 }
);</pre>

    <h2>üìì Trade Journal</h2>
    <p>Track and analyze your trading performance:</p>
    <pre class="code-block">// Add notes to trades
trader.addTradeNotes(trade.trade_id, 'Bought on breakout');

// Tag trades for categorization
trader.tagTrade(trade.trade_id, ['momentum', 'breakout']);

// Set strategy
trader.setTradeStrategy(trade.trade_id, 'trend-following', 'MA crossover');

// Filter trades
const momentumTrades = trader.getTradesByTag('momentum');
const trendTrades = trader.getTradesByStrategy('trend-following');

// Get journal summary
const summary = trader.getJournalSummary();
console.log(\`Strategies: \${summary.strategies_used}\`);
console.log(\`By strategy:\`, summary.by_strategy);

// Export to CSV
const csv = trader.exportTradesCSV();
fs.writeFileSync('trades.csv', csv);</pre>

    <h2>üîî Price Alerts</h2>
    <p>Get notified when prices cross thresholds:</p>
    <pre class="code-block">// Alert when SOL goes above $200
trader.setPriceAlert('SOL', 'above', 200, 'SOL broke $200!');

// Alert when price drops below threshold
trader.setPriceAlert('ETH', 'below', 3000);

// With webhook notification
trader.setPriceAlert('SOL', 'above', 200, 'Alert!', 'https://webhook.com');

// Manage alerts
trader.getActivePriceAlerts();
trader.cancelPriceAlert(alert.alert_id);</pre>

    <h2>üìä Volatility & Market Analysis</h2>
    <p>Monitor market conditions and volatility:</p>
    <pre class="code-block">// Get volatility metrics
const vol = trader.getVolatility('SOL', 60);
console.log(vol.volatility_level); // 'low' | 'medium' | 'high' | 'extreme'

// Market overview
const overview = trader.getMarketOverview();
console.log(overview.market_sentiment); // 'bullish' | 'bearish' | 'neutral'

// Check if conditions are favorable
const check = trader.isTradingFavorable('SOL');
console.log(check.score, check.reasons);</pre>

    <h2>üìê Position Sizing</h2>
    <p>Calculate optimal position sizes based on risk:</p>
    <pre class="code-block">// Risk 2% of portfolio with 5% stop-loss
const size = trader.calculatePositionSize('SOL', 2, 5);
console.log(size.recommended_amount);

// Get risk/reward ratio
const rr = trader.getRiskReward('SOL', 150, 140, 180);
console.log(rr.risk_reward_ratio); // 3:1
console.log(rr.recommendation); // 'good'</pre>

    <h2>üìà Performance Analytics</h2>
    <p>Detailed trading metrics and statistics:</p>
    <pre class="code-block">// Get performance analytics
const analytics = trader.getPerformanceAnalytics();

console.log('Session:', analytics.session);
// { duration_hours, trades_executed, trades_per_hour }

console.log('PnL:', analytics.pnl);
// { realized_usd, unrealized_usd, best_trade_usd, worst_trade_usd }

console.log('Execution:', analytics.execution);
// { avg_latency_ms, p95_latency_ms, success_rate }

console.log('Risk:', analytics.risk);
// { win_rate, avg_win_usd, avg_loss_usd, profit_factor }

// Get latency stats
const latency = trader.getLatencyStats();
console.log(\`Avg: \${latency.avg_ms}ms, P95: \${latency.p95_ms}ms\`);</pre>

    <h2>Alpha Detection</h2>
    <p>Detect trading opportunities with momentum and reversal signals:</p>
    <pre class="code-block">// Detect alpha signals
const alphaSignals = await trader.detectAlpha();

for (const signal of alphaSignals) {
  console.log(\`\${signal.type}: \${signal.token} \${signal.direction}\`);
  console.log(\`  Action: \${signal.suggested_action}\`);
  console.log(\`  Entry: $\${signal.entry_price}\`);
  console.log(\`  Target: $\${signal.target_price}\`);
  console.log(\`  Stop: $\${signal.stop_loss}\`);
  console.log(\`  Confidence: \${signal.confidence}%\`);
}

// Listen for alpha events
trader.on('alpha', (signal) => {
  if (signal.confidence > 70) {
    const tx = await trader.actOnSignal(signal);
    // Ready-to-sign transaction
  }
});</pre>

    <h2>Multi-Agent Orchestration</h2>
    <pre class="code-block">import { createOrchestrator } from '@cap402/sdk';

const orchestrator = createOrchestrator({
  orchestrator_id: 'trading-swarm',
  max_agents: 5
});

// Parallel execution
const results = await orchestrator.executeParallel([
  { capability_id: 'cap.price.lookup.v1', inputs: { base_token: 'SOL' } },
  { capability_id: 'cap.price.lookup.v1', inputs: { base_token: 'ETH' } }
]);

// Consensus execution
const consensus = await orchestrator.executeWithConsensus(
  'cap.price.lookup.v1',
  { base_token: 'SOL' },
  { min_agreement: 0.5 }
);</pre>
    
    <h2>Secure A2A Communication</h2>
    <p>Encrypted messaging with privacy levels and cryptographic verification:</p>
    <pre class="code-block">// Establish secure channel with another agent
const session = await trader.establishSecureChannel('agent-xyz', 'confidential');
// { session_id, status: 'established', privacy_level: 'confidential' }

// Send encrypted message
const msg = await trader.sendSecureMessage('agent-xyz', {
  type: 'trade_proposal',
  token: 'SOL',
  amount: 100
}, 'confidential');

// Verify received message
const verification = await trader.verifyMessage(incomingMessage);
if (verification.valid) {
  console.log('Verified payload:', verification.decrypted_payload);
}

// Close secure channel
await trader.closeSecureChannel('agent-xyz');</pre>

    <h3>Privacy Levels</h3>
    <table>
      <tr><th>Level</th><th>Description</th><th>Use Case</th></tr>
      <tr><td>public</td><td>No encryption, signed only</td><td>Broadcast signals</td></tr>
      <tr><td>confidential</td><td>Encrypted in transit</td><td>Trade negotiations</td></tr>
      <tr><td>private</td><td>Zero-knowledge proofs</td><td>Sensitive strategies</td></tr>
      <tr><td>maximum</td><td>Full MPC/FHE</td><td>High-value trades</td></tr>
    </table>

    <h2>Fault Tolerance</h2>
    <p>Built-in retry logic, circuit breakers, and fallback agents:</p>
    <pre class="code-block">// Configure fault tolerance
trader.setFaultConfig({
  max_retries: 3,
  retry_delay_ms: 1000,
  timeout_ms: 30000,
  fallback_agents: ['agent-backup-1', 'agent-backup-2'],
  circuit_breaker_threshold: 5
});

// Execute with automatic retries and fallbacks
const result = await trader.executeWithFaultTolerance(
  () => trader.requestQuote('agent-xyz', 'SOL', 'USDC', 100),
  'agent-xyz',
  ['agent-backup']
);

if (result.success) {
  console.log(\`Completed in \${result.attempts} attempts\`);
  if (result.used_fallback) {
    console.log(\`Used fallback: \${result.used_fallback}\`);
  }
}</pre>

    <h2>Cross-Protocol Interoperability</h2>
    <p>Communicate with agents on other protocols (Google A2A, MCP, custom):</p>
    <pre class="code-block">// Register a cross-protocol agent
trader.registerCrossProtocolAgent({
  agent_id: 'google-agent-1',
  protocol: 'a2a_google',
  endpoint: 'https://agent.example.com',
  capabilities: ['swap', 'quote']
});

// Invoke capability on cross-protocol agent
const result = await trader.invokeCrossProtocol(
  'google-agent-1',
  'swap',
  { token_in: 'SOL', token_out: 'USDC', amount: 100 }
);

// Discover agents across all protocols
const agents = await trader.discoverCrossProtocolAgents({
  protocols: ['cap402', 'a2a_google', 'mcp'],
  capability: 'swap'
});</pre>

    <h2>CLI Tools</h2>
    <pre class="code-block"># Health check
npm run cli health

# List capabilities
npm run cli capabilities

# Invoke a capability
npm run cli invoke cap.price.lookup.v1 '{"base_token":"SOL"}'

# Run examples
npm run example:trading
npm run example:monitor</pre>
    
    <h2>Zero-Config One-Liners</h2>
    <p>No setup required for common operations:</p>
    <pre class="code-block">import { prepareSwap, bestSwap, findAlpha, findPartners, autoTrader } from '@cap402/sdk';

// Prepare swap without agent setup
const tx = await prepareSwap('SOL', 'USDC', 10);
console.log(tx.summary.headline); // "Swap 10 SOL ‚Üí ~1,433 USDC"

// Get best execution route (DEX vs A2A)
const result = await bestSwap('SOL', 'USDC', 100);
console.log(result.route, result.execution_summary);

// Detect alpha signals
const signals = await findAlpha(['SOL', 'ETH', 'BTC']);
signals.forEach(s => console.log(s.token, s.direction));

// Find A2A trading partners
const partners = await findPartners('SOL', 'USDC', 100);

// Auto-starting agent with event handlers
const agent = await autoTrader(['SOL', 'ETH'], {
  onSignal: console.log,
  onAlpha: console.log
});</pre>

    <h2>Error Handling</h2>
    <p>Actionable errors with suggestions and documentation links:</p>
    <pre class="code-block">import { CAP402Error, wrapError, isRetryable, getRetryDelay } from '@cap402/sdk';

try {
  await trader.prepareSwap('SOL', 'USDC', 1000000);
} catch (error) {
  if (error instanceof CAP402Error) {
    console.log(error.code);       // 'SPENDING_LIMIT_EXCEEDED'
    console.log(error.suggestion); // 'Adjust limits or use emergencyStop()'
    console.log(error.docs_url);   // 'https://cap402.com/docs/...'
  }
  
  // Check if retryable
  if (isRetryable(error)) {
    const delay = getRetryDelay(error, attempt);
    await sleep(delay);
    // Retry...
  }
}</pre>

    <h3>Error Types</h3>
    <table>
      <tr><th>Error</th><th>Code</th><th>When</th></tr>
      <tr><td>NetworkError</td><td>NETWORK_ERROR</td><td>Connection issues</td></tr>
      <tr><td>TimeoutError</td><td>TIMEOUT_ERROR</td><td>Operation timed out</td></tr>
      <tr><td>RateLimitError</td><td>RATE_LIMIT_ERROR</td><td>Too many requests</td></tr>
      <tr><td>SlippageExceededError</td><td>SLIPPAGE_EXCEEDED</td><td>Price moved too much</td></tr>
      <tr><td>MEVRiskError</td><td>MEV_RISK_HIGH</td><td>High MEV risk detected</td></tr>
      <tr><td>QuoteExpiredError</td><td>QUOTE_EXPIRED</td><td>A2A quote expired</td></tr>
      <tr><td>SpendingLimitError</td><td>SPENDING_LIMIT_EXCEEDED</td><td>Safety limit hit</td></tr>
    </table>

    <h2>Logging & Debugging</h2>
    <pre class="code-block">import { createLogger, setLogLevel } from '@cap402/sdk';

// Create agent-specific logger
const log = createLogger('my-trader', 'debug');

// Log with categories
log.info('trade', 'Preparing swap', { token: 'SOL', amount: 10 });
log.warn('mev', 'High risk detected', { risk: 'HIGH' });

// Specialized logging
log.trade('execute', { token_in: 'SOL', token_out: 'USDC', amount: 10 });
log.a2a('quote_received', { from_agent: 'agent-xyz', price: 143.34 });
log.signal('buy', 'SOL', { confidence: 85 });

// Timer for performance
log.time('swap');
await trader.prepareSwap('SOL', 'USDC', 10);
log.timeEnd('swap', 'trade', 'Swap prepared');

// Get recent logs
const errors = log.getLogs({ level: 'error', limit: 10 });

// Set global log level
setLogLevel('warn'); // Only warn and error</pre>

    <h2>üîí Confidential Execution</h2>
    <p>For trades >$100K, use the confidential execution pipeline (Arcium MPC + Inco FHE + Noir ZK):</p>
    <pre class="code-block">// Check if confidential execution is required
const tier = await trader.getExecutionTier(150000);
// { tier: 'confidential', recommendation: 'MANDATORY: Use confidential for MEV protection' }

// Execute with full confidential pipeline
const result = await trader.executeConfidential({
  operation: 'swap',
  amount_usd: 150000,
  inputs: { token_in: 'SOL', token_out: 'USDC' },
  required_proofs: ['balance_threshold']
});

console.log(result.stages_completed);
// ['noir_eligibility', 'inco_encrypt', 'arcium_mpc', 'noir_execution_proof']
console.log(\`Slippage saved: \${result.slippage_saved_bps} bps\`);
console.log(\`Fee: $\${result.fee_usd}\`);</pre>

    <h3>Encrypted Orderbooks (Dark Pools)</h3>
    <pre class="code-block">// Create encrypted orderbook
const orderbook = await trader.createEncryptedOrderbook('SOL/USDC');

// Submit encrypted order (price/size hidden via FHE)
const order = await trader.submitEncryptedOrder(
  orderbook.orderbook_id,
  'bid',
  145.50,  // price - will be encrypted
  100      // size - will be encrypted
);

// Match orders using FHE comparison (no one sees prices)
const matches = await trader.matchEncryptedOrders(orderbook.orderbook_id);</pre>

    <h3>Private Auctions</h3>
    <pre class="code-block">// Create sealed-bid auction
const auction = await trader.createPrivateAuction('NFT-123', 1000);

// Submit encrypted bid
const bid = await trader.submitAuctionBid(auction.auction_id, 1500);

// Settle - winner determined without revealing losing bids
const result = await trader.settleAuction(auction.auction_id);
console.log(\`Winner: \${result.winner}\`);</pre>

    <h3>Threshold Signatures</h3>
    <pre class="code-block">// Multi-party signing (2-of-3)
const signature = await trader.thresholdSign({
  signers: ['agent-1', 'agent-2', 'agent-3'],
  threshold: 2,
  message_hash: '0x...'
});
// No single party sees the full key</pre>

    <h3>Performance Proofs</h3>
    <pre class="code-block">// Prove performance without revealing strategy
const proof = await trader.provePerformance({
  claim_type: 'win_rate',  // or 'volume', 'profitability'
  metrics: {
    total_trades: 1000,
    profitable_trades: 650,
    total_volume_usd: 5000000,
    total_pnl_usd: 125000
  }
});
// Proof shows win_rate > 50% without revealing exact numbers</pre>

    <h2>Key Principles</h2>
    <ul>
      <li><strong>Autonomous Decision-Making</strong> ‚Äî Agents monitor, analyze, and prepare transactions 24/7</li>
      <li><strong>User Control</strong> ‚Äî You sign transactions in your own wallet. We never hold keys.</li>
      <li><strong>Safety First</strong> ‚Äî Spending limits, rate controls, and emergency stop built-in</li>
      <li><strong>MEV Protection</strong> ‚Äî Risk analysis before every trade</li>
      <li><strong>Confidential Execution</strong> ‚Äî Mandatory privacy for large trades via Arcium/Inco/Noir</li>
      <li><strong>Zero Configuration</strong> ‚Äî Sensible defaults, one-liner APIs</li>
      <li><strong>Actionable Errors</strong> ‚Äî Every error includes suggestions and docs links</li>
      <li><strong>Structured Logging</strong> ‚Äî Debug with context, categories, and timers</li>
    </ul>
  </div>
  <script>lucide.createIcons();</script>
</body>
</html>
